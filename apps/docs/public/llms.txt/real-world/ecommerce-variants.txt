# JSSON Documentation ‚Äî LLM Mode
Source: ecommerce-variants.mdx
Version: 0.0.5
Generated: 2025-12-02T22:05:18.104Z

## Table of Contents
- 0.1. The Problem
- 0.2. The JSSON Solution
- 0.3. Output
- 0.4. Advanced: Conditional Pricing
- 0.5. Flattening for APIs
- 0.6. Key Features Used‚Ä¢ Nested Maps ‚Äî Three levels deep for size √ó color √ó material‚Ä¢ Conditional Logic ‚Äî Dynamic pricing based on attributes‚Ä¢ String Concatenation ‚Äî Generate SKUs automatically‚Ä¢ Computed Fields ‚Äî Calculate prices, determine featured products
- 0.7. Real-World Applications
- 0.8. Benefits
- 0.9. Next Steps‚Ä¢ [Nested Maps Reference](/reference/syntax/#nested-map-transformations)‚Ä¢ [Advanced Patterns](/guides/advanced-patterns/)‚Ä¢ [Scheduling Matrix Example](/real-world/scheduling/)

## Content

Managing product variants in e-commerce is a common challenge. When you have multiple sizes, colors, and materials, manually creating every combination becomes tedious and error-prone.

0.1. The Problem

An e-commerce store sells t-shirts in:‚Ä¢ 5 sizes: XS, S, M, L, XL‚Ä¢ 4 colors: Black, White, Navy, Gray‚Ä¢ 2 materials: Cotton, Polyester

That's 40 unique product variants to manage. In traditional JSON, you'd need to manually write all 40 objects:

``json
{
  "products": [
    {
      "sku": "XS-Black-Cotton",
      "size": "XS",
      "color": "Black",
      "material": "Cotton",
      "price": 29.99,
      "inStock": true
    },
    {
      "sku": "XS-Black-Polyester",
      "size": "XS",
      "color": "Black",
      "material": "Polyester",
      "price": 24.99,
      "inStock": true
    },
    {
      "sku": "XS-White-Cotton",
      "size": "XS",
      "color": "White",
      "material": "Cotton",
      "price": 29.99,
      "inStock": true
    }
    // ... 37 more variants üò∞
  ]
}
``

Problems:‚Ä¢ ‚ùå Extremely repetitive‚Ä¢ ‚ùå Easy to make mistakes‚Ä¢ ‚ùå Hard to update pricing‚Ä¢ ‚ùå Difficult to add new sizes/colors

0.2. The JSSON Solution

With nested maps (v0.0.5), generate all combinations automatically:



That's it! 8 lines generate all 40 variants.

0.3. Output



0.4. Advanced: Conditional Pricing

Add dynamic pricing based on multiple factors:



0.5. Flattening for APIs

If you need a flat array instead of nested arrays, use a template with ranges:



0.6. Key Features Used‚Ä¢ Nested Maps ‚Äî Three levels deep for size √ó color √ó material‚Ä¢ Conditional Logic ‚Äî Dynamic pricing based on attributes‚Ä¢ String Concatenation ‚Äî Generate SKUs automatically‚Ä¢ Computed Fields ‚Äî Calculate prices, determine featured products

0.7. Real-World Applications

This pattern is perfect for:‚Ä¢ Fashion E-commerce ‚Äî Clothing with multiple size/color options‚Ä¢ Furniture Stores ‚Äî Products with material/finish/size variants‚Ä¢ Electronics ‚Äî Devices with storage/color/carrier combinations‚Ä¢ Food Products ‚Äî Items with flavor/size/packaging options‚Ä¢ Subscription Plans ‚Äî Feature matrix across tiers and billing cycles

0.8. Benefits

90% less code ‚Äî 8 lines vs 200+ lines of JSON  
Zero duplication ‚Äî Define logic once  
Easy updates ‚Äî Change pricing in one place  
No mistakes ‚Äî Automatic generation prevents typos  
Scalable ‚Äî Add new sizes/colors instantly

0.9. Next Steps‚Ä¢ [Nested Maps Reference](/reference/syntax/#nested-map-transformations)‚Ä¢ [Advanced Patterns](/guides/advanced-patterns/)‚Ä¢ [Scheduling Matrix Example](/real-world/scheduling/)