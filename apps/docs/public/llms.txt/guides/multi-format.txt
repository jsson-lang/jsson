# JSSON Documentation — LLM Mode
Source: multi-format.mdx
Version: 0.0.5
Generated: 2025-11-29T17:56:41.005Z

## Table of Contents
- 0.1. Supported Formats
- 0.2. How It Works
- 0.2.1. Example
- 0.3. TypeScript Generation
- 0.3.1. Features
- 1. as const Assertions: All objects are generated with as const, making them immutable and narrowing types to their literal values.
- 2. Type Inference: JSSON automatically exports a TypeScript type for each top-level object (e.g., export type Server = typeof server).
- 3. Zero Runtime: The output is pure TypeScript/JavaScript. No JSSON runtime is needed in your application.
- 0.3.2. Use Case: Design Systems

## Content

JSSON is a universal meta-format. This means you can write your configuration logic once in JSSON and output it to whatever format your tools require.

0.1. Supported Formats

 •  Format          •  CLI Flag   •  Best For                                          • 
 •  --------------  •  ---------  •  ------------------------------------------------  • 
 •  JSON        •  Default    •  APIs, Web Configs, Data Interchange               • 
 •  YAML        •  -f yaml  •  Kubernetes, CI/CD, CloudFormation                 • 
 •  TOML        •  -f toml  •  Rust Configs, Python (pyproject.toml), Hugo       • 
 •  TypeScript  •  -f ts    •  Frontend Constants, Design Systems, Shared Types  • 

0.2. How It Works

The JSSON compiler takes your source code, evaluates all logic (templates, maps, ranges, expressions), and then serializes the resulting data structure into the target format.

0.2.1. Example

Consider this JSSON file defining a server configuration:



{" "}



{" "}



  
</Tabs>

0.3. TypeScript Generation

The TypeScript transpiler is particularly powerful because it bridges the gap between your configuration and your application code.

0.3.1. Features

1. as const Assertions: All objects are generated with as const, making them immutable and narrowing types to their literal values.
2. Type Inference: JSSON automatically exports a TypeScript type for each top-level object (e.g., export type Server = typeof server).
3. Zero Runtime: The output is pure TypeScript/JavaScript. No JSSON runtime is needed in your application.

0.3.2. Use Case: Design Systems

You can define your design tokens in JSSON and generate typed TypeScript constants for your frontend:

``jsson
// tokens.jsson
colors {
  primary = "#0070f3"
  secondary = "#ff4081"

  gray [
    template { shade, value }
    map (i) = { shade = i * 100, value = "#" + i + i + i }
    1..9
  ]
}
`

Generates:

`typescript
export const colors = {
  primary: "#0070f3",
  secondary: "#ff4081",
  gray: [
    { shade: 100, value: "#111" },
    { shade: 200, value: "#222" },
    // ...
  ],
} as const;

export type Colors = typeof colors;
``

Now you have full autocompletion for your design tokens in your React/Vue/Svelte components!