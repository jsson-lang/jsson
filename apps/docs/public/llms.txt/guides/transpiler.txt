# JSSON Documentation — LLM Mode
Source: transpiler.mdx
Version: 0.0.5
Generated: 2025-11-29T17:56:41.029Z

## Table of Contents
- 0.1. How It Works
- 0.1.1. 1. Lexer (Tokenization)
- 0.1.2. 2. Parser (AST Generation)
- 0.1.3. 3. Transpiler (Code Generation)
- 0.2. Using the Transpiler
- 0.2.1. Command Line
- 1. DEFAULT (JSON)
- 2. YAML
- 3. TYPESCRIPT
- 3.0.1. Programmatic Usage (Go)
- 3.0.2. Reading from Files
- 3.1. Output Formats
- 3.1.1. Selecting Format
- 3.2. Performance Considerations
- 3.2.1. File Size
- 3.2.2. Memory Usage
- 1. Splitting with includes
- 2. Processing in chunks
- 3.2.3. Optimization Tips
- 1. Use includes for large configs:
- 2. Avoid deeply nested structures:
- 3. Use template arrays efficiently:
- 3.3. Error Handling
- 3.3.1. Lex Errors
- 3.3.2. Parse Errors
- 3.3.3. Transpile Errors
- 3.4. Extending the Transpiler
- 3.4.1. Custom Transformations
- 3.5. Integration Examples
- 3.5.1. Web Server
- 3.6. What's Next?• [AST Reference](/reference/ast/) — Understand the Abstract Syntax Tree• [Errors & Debugging](/reference/errors/) — Handle errors gracefully• [CLI Guide](/guides/cli/) — Master the command-line tool

## Content

The JSSON transpiler is the engine that converts your clean JSSON syntax into valid JSON, YAML, TOML, or TypeScript. Let's explore how it works and how to use it! ⚙️

0.1. How It Works

The transpiler follows a three-stage pipeline:

``
JSSON Source → Lexer → Parser → Transpiler → Output
`

0.1.1. 1. Lexer (Tokenization)

Breaks your JSSON into tokens:

`jsson
name = João
`

Becomes:

`
IDENT("name") ASSIGN IDENT("João")
`

0.1.2. 2. Parser (AST Generation)

Creates an Abstract Syntax Tree:

`
Program
└── AssignmentStatement
    ├── name: "name"
    └── value: StringLiteral("João")
`

0.1.3. 3. Transpiler (Code Generation)

Converts the AST to the target format (JSON, YAML, etc.):

`json
{
  "name": "João"
}
`

0.2. Using the Transpiler

0.2.1. Command Line

The easiest way:

`bash

1. DEFAULT (JSON)
--------------
jsson -i input.jsson -o output.json


2. YAML
----
jsson -i input.jsson -f yaml


3. TYPESCRIPT
----------
jsson -i input.jsson -f ts
`

3.0.1. Programmatic Usage (Go)

Use JSSON as a library in your Go code:

`go
package main


    "fmt"
    "jsson/internal/lexer"
    "jsson/internal/parser"
    "jsson/internal/transpiler"
)

func main() {
    // Your JSSON source
    source := 
    app {
        name = "My App"
        version = "1.0.0"
    }
    

    // Step 1: Lex
    l := lexer.New(source)

    // Step 2: Parse
    p := parser.New(l)
    program := p.ParseProgram()

    // Check for parse errors
    if len(p.Errors()) > 0 {
        for _, err := range p.Errors() {
            fmt.Println(err)
        }
        return
    }

    // Step 3: Transpile
    // New(program, workingDir, includeMode, sourceFile)
    t := transpiler.New(program, ".", "keep", "main.jsson")

    // Transpile to JSON
    json, err := t.Transpile()
    if err != nil {
        fmt.Println("Transpile error:", err)
        return
    }

    fmt.Println(string(json))
}
`

3.0.2. Reading from Files

`go
package main


    "fmt"
    "os"
    "path/filepath"
    "jsson/internal/lexer"
    "jsson/internal/parser"
    "jsson/internal/transpiler"
)

func transpileFile(inputPath, outputPath string) error {
    // Read input file
    content, err := os.ReadFile(inputPath)
    if err != nil {
        return err
    }

    // Lex and parse
    l := lexer.New(string(content))
    l.SetSourceFile(inputPath)  // For better error messages

    p := parser.New(l)
    program := p.ParseProgram()

    if len(p.Errors()) > 0 {
        for _, err := range p.Errors() {
            fmt.Println(err)
        }
        return fmt.Errorf("parse errors")
    }

    // Transpile
    workingDir := filepath.Dir(inputPath)
    t := transpiler.New(program, workingDir, "keep", inputPath)

    json, err := t.Transpile()
    if err != nil {
        return err
    }

    // Write output
    return os.WriteFile(outputPath, json, 0644)
}
`

3.1. Output Formats

JSSON currently supports transpilation to:• JSON (Default) — For APIs and general config• YAML — For Kubernetes, CI/CD, and cloud infrastructure• TOML — For Rust/Go/Python configuration• TypeScript — For type-safe frontend constants

3.1.1. Selecting Format

In the Go API, use the specific method for your desired format:

`go
// JSON
json, _ := t.Transpile()

// YAML
yaml, _ := t.TranspileToYAML()

// TOML
toml, _ := t.TranspileToTOML()

// TypeScript
ts, _ := t.TranspileToTypeScript()
`

3.2. Performance Considerations

3.2.1. File Size

JSSON handles files efficiently:• Small files (< 1KB): Instant• Medium files (1-100KB): < 100ms• Large files (> 100KB): < 1s

3.2.2. Memory Usage

The transpiler loads the entire file into memory. For very large files (> 10MB), consider:

1. Splitting with includes
2. Processing in chunks

3.2.3. Optimization Tips

1. Use includes for large configs:

`jsson
// Instead of one 1000-line file
include "users.jsson"      // 200 lines
include "products.jsson"   // 300 lines
include "settings.jsson"   // 500 lines
`

2. Avoid deeply nested structures:

`jsson
// This is fine
user {
  profile {
    settings {
      theme = dark
    }
  }
}

// This might be slow (10+ levels deep)
a { b { c { d { e { f { g { h { i { j {
  value = deep
}}}}}}}}}}
`

3. Use template arrays efficiently:

`jsson
// Good - 1000 users
users [
  template { name, email }
  // ... 1000 rows
]

// Better - split into multiple files
include "users-1-500.jsson"
include "users-501-1000.jsson"
`

3.3. Error Handling

The transpiler provides detailed error messages:

3.3.1. Lex Errors

`
Lex goblin: config.jsson:15:8 — Illegal character: '@'
`

3.3.2. Parse Errors

`
Parse wizard: config.jsson:20:5 — Unexpected token: expected '=', got '{'
`

3.3.3. Transpile Errors

`
Transpiler gremlin: config.jsson:25:10 — Undefined reference: 'config.port'
`

See the [Errors & Debugging](/reference/errors/) guide for details!

3.4. Extending the Transpiler

3.4.1. Custom Transformations

You can modify the AST before transpiling:

`go
// Example: Add a timestamp to all objects
func addTimestamp(program ast.Program) {
    for _, stmt := range program.Statements {
        if assign, ok := stmt.(ast.AssignmentStatement); ok {
            if obj, ok := assign.Value.(ast.ObjectLiteral); ok {
                // Add timestamp field
                obj.Pairs["_timestamp"] = &ast.StringLiteral{
                    Value: time.Now().Format(time.RFC3339),
                }
            }
        }
    }
}

// Use it
program := p.ParseProgram()
addTimestamp(program)
t := transpiler.New(program, ".", "keep", "main.jsson")
json, _ := t.Transpile()
`

3.5. Integration Examples

3.5.1. Web Server

`go
package main


    "net/http"
    "io"
    "jsson/internal/lexer"
    "jsson/internal/parser"
    "jsson/internal/transpiler"
)

func transpileHandler(w http.ResponseWriter, r http.Request) {
    // Read JSSON from request body
    body, _ := io.ReadAll(r.Body)

    // Transpile
    l := lexer.New(string(body))
    p := parser.New(l)
    program := p.ParseProgram()

    if len(p.Errors()) > 0 {
        http.Error(w, p.Errors()[0], http.StatusBadRequest)
        return
    }

    t := transpiler.New(program, ".", "keep", "request.jsson")
    json, err := t.Transpile()
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    w.Write(json)
}

func main() {
    http.HandleFunc("/transpile", transpileHandler)
    http.ListenAndServe(":8080", nil)
}
``

3.6. What's Next?• [AST Reference](/reference/ast/) — Understand the Abstract Syntax Tree• [Errors & Debugging](/reference/errors/) — Handle errors gracefully• [CLI Guide](/guides/cli/) — Master the command-line tool

The transpiler is the heart of JSSON — now you know how it works! ⚙️