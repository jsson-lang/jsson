---
title: Kubernetes Configuration
description: Manage multi-environment Kubernetes deployments with JSSON - one template, multiple environments with conditional logic.
---

import { Code, Tabs, TabItem } from "@astrojs/starlight/components";

Generate Kubernetes manifests for multiple environments (prod/staging/dev) from a single JSSON template with environment-specific configurations.

## The Problem

Managing Kubernetes configs across environments means:

- **Duplicate manifests** — Separate YAML/JSON files for each environment
- **Inconsistent naming** — Easy to make mistakes in resource names
- **Hard to update** — Changes require editing multiple files
- **Error-prone** — Copy-paste errors in similar configs

## The JSSON Solution

**One template** generates configs for all environments with conditional logic!

<Tabs>
  <TabItem label="JSSON">
    <Code
      lang="javascript"
      code={`deployments [
  template { appName, env, replicas }
  
  map (deploy) = {
    apiVersion = "apps/v1"
    kind = "Deployment"
    name = deploy.appName + "-" + deploy.env
    namespace = deploy.env
    replicas = deploy.replicas
    
    // Environment-specific image tag
    image = "registry/" + deploy.appName + ":" + (deploy.env == "prod" ? "stable" : "latest")
    
    // Environment-specific resources
    memoryRequest = deploy.env == "prod" ? "512Mi" : "256Mi"
    cpuRequest = deploy.env == "prod" ? "500m" : "250m"
    memoryLimit = deploy.env == "prod" ? "1Gi" : "512Mi"
    cpuLimit = deploy.env == "prod" ? "1000m" : "500m"
    
    // Environment variables
    environment = deploy.env
    logLevel = deploy.env == "prod" ? "error" : "debug"
  }
  
  // Production: high replicas
  "api", "prod", 5
  "web", "prod", 3
  
  // Staging: medium replicas
  "api", "staging", 2
  "web", "staging", 2
  
  // Development: minimal replicas
  "api", "dev", 1
  "web", "dev", 1
]`}
    />
  </TabItem>
  <TabItem label="JSON Output">
    <Code
      lang="json"
      code={`{
  "deployments": [
    {
      "apiVersion": "apps/v1",
      "kind": "Deployment",
      "name": "api-prod",
      "namespace": "prod",
      "replicas": 5,
      "image": "registry/api:stable",
      "memoryRequest": "512Mi",
      "cpuRequest": "500m",
      "memoryLimit": "1Gi",
      "cpuLimit": "1000m",
      "environment": "prod",
      "logLevel": "error"
    },
    {
      "apiVersion": "apps/v1",
      "kind": "Deployment",
      "name": "web-prod",
      "namespace": "prod",
      "replicas": 3,
      "image": "registry/web:stable"
      // ... more fields
    }
    // ... 4 more deployments
  ]
}`}
    />
  </TabItem>
</Tabs>

## Key Features Used

### Conditional Logic

<Code lang="javascript" code={`// Different image tags per environment
image = "registry/" + deploy.appName + ":" + (deploy.env == "prod" ? "stable" : "latest")

// Different resources per environment
memoryRequest = deploy.env == "prod" ? "512Mi" : "256Mi"`} />

### String Concatenation

<Code
  lang="javascript"
  code={`// Consistent naming convention
name = deploy.appName + "-" + deploy.env
// Results in: "api-prod", "web-staging", etc.`}
/>

### Templates for Structure

<Code lang="javascript" code={`template { appName, env, replicas }

// Define once, use for all apps and environments
"api", "prod", 5
"web", "staging", 2`} />

## Services Configuration

<Code
  lang="javascript"
  code={`services [
  template { appName, env, port }
  
  map (svc) = {
    apiVersion = "v1"
    kind = "Service"
    name = svc.appName + "-" + svc.env
    namespace = svc.env
    type = svc.env == "prod" ? "LoadBalancer" : "ClusterIP"
    port = svc.port
    targetPort = svc.port
    protocol = "TCP"
  }
  
  "api", "prod", 8080
  "web", "prod", 3000
  "api", "staging", 8080
  "web", "staging", 3000
]`}
/>

## ConfigMaps

<Code
  lang="javascript"
  code={`configMaps [
  template { env }
  
  map (cfg) = {
    apiVersion = "v1"
    kind = "ConfigMap"
    name = "app-config-" + cfg.env
    namespace = cfg.env
    databaseHost = "postgres-" + cfg.env + ".internal"
    redisHost = "redis-" + cfg.env + ".internal"
    cacheTTL = cfg.env == "prod" ? "3600" : "60"
    featureFlags = cfg.env == "prod" ? "stable" : "experimental"
  }
  
  "prod"
  "staging"
  "dev"
]`}
/>

## Benefits

**Consistency** — Same naming conventions across all resources  
**DRY** — Define once, generate for all environments  
**Type Safety** — Templates ensure all required fields are present  
**Easy Updates** — Change one template, update all environments  
**Less Error-Prone** — No copy-paste mistakes

## When to Use This Pattern

**Perfect for:**

- Multi-environment Kubernetes deployments
- Microservices with similar configs
- Infrastructure as code
- Helm chart alternatives
- GitOps workflows

**Not ideal for:**

- Extremely different configs per environment
- One-off, unique resources
- Complex Helm chart replacements

## Try It Yourself!

1. Save the deployments example to `k8s.jsson`
2. Run: `jsson -i k8s.jsson -o k8s.json`
3. Use the JSON to generate Kubernetes manifests!

## What's Next?

- **[API Gateway](/real-world/api-gateway/)** — Microservices routing
- **[Feature Flags](/real-world/feature-flags/)** — Environment configs
- **[Overview](/real-world/overview/)** — See all examples

One template, all environments! ☸️
