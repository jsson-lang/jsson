package transpiler

import (
	"encoding/json"
	"fmt"
	"jsson/internal/ast"
	ie "jsson/internal/errors"
	"jsson/internal/lexer"
	"jsson/internal/parser"
	"jsson/internal/token"
	"os"
	"path/filepath"
	"strings"
)

// RangeResult wraps a slice generated by a range expression
// This allows ArrayLiteral to distinguish between a range (to be flattened) and a nested array
type RangeResult struct {
	Values []interface{}
}

type Transpiler struct {
	program *ast.Program
	baseDir string
	// includeCache stores previously transpiled include outputs keyed by absolute path
	includeCache map[string]map[string]interface{}
	// inProgress marks includes currently being processed to detect cycles
	inProgress map[string]bool
	// mergeMode controls include merge behavior: "keep" (default), "overwrite", "error"
	mergeMode string
	// sourceFile is the path to the source file being transpiled (optional)
	sourceFile string
	// symbolTable stores variable declarations (name := value)
	symbolTable map[string]interface{}
	// presetTable stores preset definitions (@preset "name" { ... })
	presetTable map[string]*ast.ObjectLiteral
	// Streaming support
	streamingEnabled bool
	streamThreshold  int64 // Auto-enable streaming if range size > threshold
}

func New(program *ast.Program, baseDir string, mergeMode string, sourceFile string) *Transpiler {
	if mergeMode == "" {
		mergeMode = "keep"
	}
	return &Transpiler{
		program:          program,
		baseDir:          baseDir,
		includeCache:     make(map[string]map[string]interface{}),
		inProgress:       make(map[string]bool),
		mergeMode:        mergeMode,
		sourceFile:       sourceFile,
		symbolTable:      make(map[string]interface{}),
		presetTable:      make(map[string]*ast.ObjectLiteral),
		streamingEnabled: false,
		streamThreshold:  10000, // Default: auto-enable streaming for ranges > 10k items
	}
}

func (t *Transpiler) Transpile() ([]byte, error) {
	root := make(map[string]interface{})

	for _, stmt := range t.program.Statements {
		switch s := stmt.(type) {
		case *ast.PresetStatement:
			// Preset definitions are stored in preset table but not added to output
			t.presetTable[s.Name.Value] = s.Body
		case *ast.VariableDeclaration:
			// Variable declarations are stored in symbol table but not added to output
			val, err := t.evalExpression(s.Value, nil)
			if err != nil {
				return nil, err
			}
			t.symbolTable[s.Name.Value] = val
		case *ast.AssignmentStatement:
			key := s.Name.Value
			val, err := t.evalExpression(s.Value, nil)
			if err != nil {
				return nil, err
			}
			// Store in symbol table so it can be referenced by other expressions
			t.symbolTable[key] = val
			// Also add to output
			root[key] = val
		case *ast.IncludeStatement:
			// Read included file and merge its output into root (do not overwrite existing keys)
			includePath := s.Path.Value

			// Resolve path relative to the current Transpiler baseDir when not absolute
			var includeAbs string
			if filepath.IsAbs(includePath) {
				includeAbs = filepath.Clean(includePath)
			} else {
				includeAbs = filepath.Clean(filepath.Join(t.baseDir, includePath))
			}

			// Detect cyclic include
			if t.inProgress[includeAbs] {
				return nil, t.errfNodeMsg(s, ie.CyclicInclude(includeAbs))
			}

			// If cached, use cached result
			if cached, ok := t.includeCache[includeAbs]; ok {
				for k, v := range cached {
					if _, exists := root[k]; !exists {
						root[k] = v
					}
				}
				break
			}

			// Mark as in-progress
			t.inProgress[includeAbs] = true

			data, err := os.ReadFile(includeAbs)
			if err != nil {
				t.inProgress[includeAbs] = false
				return nil, t.errfNode(s, "could not read include file %q — gremlin can't find it: %v", s.Path.Value, err)
			}

			l := lexer.New(string(data))
			l.SetSourceFile(includeAbs)
			p := parser.New(l)
			prog := p.ParseProgram()
			if len(p.Errors()) > 0 {
				t.inProgress[includeAbs] = false
				return nil, t.errfNode(s, "parser errors in included file %q — wizard got confused: %v", s.Path.Value, p.Errors())
			}

			// Create a transpiler for the included program, setting its baseDir to the included file's dir
			incBase := filepath.Dir(includeAbs)
			incT := New(prog, incBase, t.mergeMode, includeAbs)
			// share cache and inProgress maps so nested includes use the same state
			incT.includeCache = t.includeCache
			incT.inProgress = t.inProgress

			incJSON, err := incT.Transpile()
			if err != nil {
				t.inProgress[includeAbs] = false
				return nil, t.errfNode(s, "transpile error in included file %q: %v", s.Path.Value, err)
			}

			var incRoot map[string]interface{}
			if err := json.Unmarshal(incJSON, &incRoot); err != nil {
				t.inProgress[includeAbs] = false
				return nil, t.errfNode(s, "invalid json from include %q: %v", s.Path.Value, err)
			}

			// Cache result
			t.includeCache[includeAbs] = incRoot
			// Done processing
			t.inProgress[includeAbs] = false

			// Merge according to mergeMode
			for k, v := range incRoot {
				switch t.mergeMode {
				case "keep":
					if _, exists := root[k]; !exists {
						root[k] = v
					}
				case "overwrite":
					root[k] = v
				case "error":
					if _, exists := root[k]; exists {
						return nil, t.errfNode(s, "include merge conflict for key %q from %s", k, includeAbs)
					}
					root[k] = v
				default:
					if _, exists := root[k]; !exists {
						root[k] = v
					}
				}
			}
		}
	}

	// Convert any RangeResult to plain slices before JSON marshaling
	root = t.convertRangeResults(root).(map[string]interface{})

	return json.MarshalIndent(root, "", "  ")
}

// convertRangeResults recursively converts RangeResult to plain []interface{}
func (t *Transpiler) convertRangeResults(v interface{}) interface{} {
	switch val := v.(type) {
	case RangeResult:
		// Convert RangeResult to plain slice
		result := make([]interface{}, len(val.Values))
		for i, item := range val.Values {
			result[i] = t.convertRangeResults(item)
		}
		return result
	case map[string]interface{}:
		// Recursively convert map values
		result := make(map[string]interface{})
		for k, item := range val {
			result[k] = t.convertRangeResults(item)
		}
		return result
	case []interface{}:
		// Recursively convert array elements
		result := make([]interface{}, len(val))
		for i, item := range val {
			result[i] = t.convertRangeResults(item)
		}
		return result
	default:
		return v
	}
}

func (t *Transpiler) errf(format string, args ...interface{}) error {
	prefix := "Transpile gremlin:"
	if t != nil && t.sourceFile != "" {
		ctx := ie.FormatContext(t.sourceFile, 1, 1)
		return fmt.Errorf("%s %s — %s", prefix, ctx, fmt.Sprintf(format, args...))
	}
	return fmt.Errorf("%s — %s", prefix, fmt.Sprintf(format, args...))
}

func (t *Transpiler) errfNode(node ast.Node, format string, args ...interface{}) error {
	prefix := "Transpile gremlin:"
	var line, col int
	if node != nil {
		switch n := node.(type) {
		case *ast.AssignmentStatement:
			line, col = n.Token.Line, n.Token.Column
		case *ast.IncludeStatement:
			line, col = n.Token.Line, n.Token.Column
		case *ast.PresetStatement:
			line, col = n.Token.Line, n.Token.Column
		case *ast.PresetReference:
			line, col = n.Token.Line, n.Token.Column
		case *ast.IntegerLiteral:
			line, col = n.Token.Line, n.Token.Column
		case *ast.FloatLiteral:
			line, col = n.Token.Line, n.Token.Column
		case *ast.StringLiteral:
			line, col = n.Token.Line, n.Token.Column
		case *ast.Identifier:
			line, col = n.Token.Line, n.Token.Column
		case *ast.ObjectLiteral:
			line, col = n.Token.Line, n.Token.Column
		case *ast.ArrayLiteral:
			line, col = n.Token.Line, n.Token.Column
		case *ast.RangeExpression:
			line, col = n.Token.Line, n.Token.Column
		case *ast.ArrayTemplate:
			line, col = n.Token.Line, n.Token.Column
		case *ast.MapClause:
			line, col = n.Token.Line, n.Token.Column
		case *ast.BinaryExpression:
			line, col = n.Token.Line, n.Token.Column
		case *ast.MemberExpression:
			line, col = n.Token.Line, n.Token.Column
		case *ast.MapExpression:
			line, col = n.Token.Line, n.Token.Column
		case *ast.ConditionalExpression:
			line, col = n.Token.Line, n.Token.Column
		case *ast.InterpolatedString:
			line, col = n.Token.Line, n.Token.Column
		case *ast.BooleanLiteral:
			line, col = n.Token.Line, n.Token.Column
		default:
			line, col = 0, 0
		}
	}

	if t != nil && t.sourceFile != "" {
		if line > 0 && col > 0 {
			ctx := ie.FormatContext(t.sourceFile, line, col)
			return fmt.Errorf("%s %s — %s", prefix, ctx, fmt.Sprintf(format, args...))
		}
		// fallback to file-only context
		ctx := ie.FormatContext(t.sourceFile, 1, 1)
		return fmt.Errorf("%s %s — %s", prefix, ctx, fmt.Sprintf(format, args...))
	}
	return fmt.Errorf("%s — %s", prefix, fmt.Sprintf(format, args...))
}

// errfNodeMsg formats an already-formatted error message with node context
func (t *Transpiler) errfNodeMsg(node ast.Node, msg string) error {
	prefix := "Transpile gremlin:"
	var line, col int
	if node != nil {
		switch n := node.(type) {
		case *ast.AssignmentStatement:
			line, col = n.Token.Line, n.Token.Column
		case *ast.IncludeStatement:
			line, col = n.Token.Line, n.Token.Column
		case *ast.PresetStatement:
			line, col = n.Token.Line, n.Token.Column
		case *ast.PresetReference:
			line, col = n.Token.Line, n.Token.Column
		case *ast.IntegerLiteral:
			line, col = n.Token.Line, n.Token.Column
		case *ast.FloatLiteral:
			line, col = n.Token.Line, n.Token.Column
		case *ast.StringLiteral:
			line, col = n.Token.Line, n.Token.Column
		case *ast.Identifier:
			line, col = n.Token.Line, n.Token.Column
		case *ast.ObjectLiteral:
			line, col = n.Token.Line, n.Token.Column
		case *ast.ArrayLiteral:
			line, col = n.Token.Line, n.Token.Column
		case *ast.RangeExpression:
			line, col = n.Token.Line, n.Token.Column
		case *ast.ArrayTemplate:
			line, col = n.Token.Line, n.Token.Column
		case *ast.MapClause:
			line, col = n.Token.Line, n.Token.Column
		case *ast.BinaryExpression:
			line, col = n.Token.Line, n.Token.Column
		case *ast.MemberExpression:
			line, col = n.Token.Line, n.Token.Column
		case *ast.MapExpression:
			line, col = n.Token.Line, n.Token.Column
		case *ast.ConditionalExpression:
			line, col = n.Token.Line, n.Token.Column
		case *ast.InterpolatedString:
			line, col = n.Token.Line, n.Token.Column
		case *ast.BooleanLiteral:
			line, col = n.Token.Line, n.Token.Column
		default:
			line, col = 0, 0
		}
	}

	if t != nil && t.sourceFile != "" {
		if line > 0 && col > 0 {
			ctx := ie.FormatContext(t.sourceFile, line, col)
			return fmt.Errorf("%s %s — %s", prefix, ctx, msg)
		}

		ctx := ie.FormatContext(t.sourceFile, 1, 1)
		return fmt.Errorf("%s %s — %s", prefix, ctx, msg)
	}
	return fmt.Errorf("%s — %s", prefix, msg)
}

// errMsg formats an already-formatted error message with context
func (t *Transpiler) errMsg(msg string) error {
	prefix := "Transpile gremlin:"
	if t != nil && t.sourceFile != "" {
		ctx := ie.FormatContext(t.sourceFile, 1, 1)
		return fmt.Errorf("%s %s — %s", prefix, ctx, msg)
	}
	return fmt.Errorf("%s — %s", prefix, msg)
}

func (t *Transpiler) evalExpression(expr ast.Expression, ctx map[string]interface{}) (interface{}, error) {
	switch e := expr.(type) {
	case *ast.IntegerLiteral:
		return e.Value, nil
	case *ast.FloatLiteral:
		return e.Value, nil
	case *ast.BooleanLiteral:
		return e.Value, nil
	case *ast.StringLiteral:
		return e.Value, nil
	case *ast.PresetReference:
		// Look up the preset by name
		presetName := e.Name.Value
		presetBody, exists := t.presetTable[presetName]
		if !exists {
			return nil, t.errfNode(e, "preset %q not found — define it with @preset %q { ... }", presetName, presetName)
		}

		// Evaluate the preset body to get base values
		baseVal, err := t.evalExpression(presetBody, ctx)
		if err != nil {
			return nil, err
		}

		baseObj, ok := baseVal.(map[string]interface{})
		if !ok {
			return nil, t.errfNode(e, "preset %q did not evaluate to an object", presetName)
		}

		// If there are overrides, merge them on top
		if e.Overrides != nil {
			overridesVal, err := t.evalExpression(e.Overrides, ctx)
			if err != nil {
				return nil, err
			}

			overridesObj, ok := overridesVal.(map[string]interface{})
			if !ok {
				return nil, t.errfNode(e, "preset overrides must be an object")
			}

			// Merge: overrides take precedence
			result := make(map[string]interface{})
			for k, v := range baseObj {
				result[k] = v
			}
			for k, v := range overridesObj {
				result[k] = v
			}
			return result, nil
		}

		// Return a copy to avoid mutation issues
		result := make(map[string]interface{})
		for k, v := range baseObj {
			result[k] = v
		}
		return result, nil
	case *ast.MapExpression:
		// Evaluate the array to be mapped
		leftVal, err := t.evalExpression(e.Left, ctx)
		if err != nil {
			return nil, err
		}

		// Ensure it's an array (slice). Accept RangeResult (wraps generated slice) as well.
		var items []interface{}
		switch v := leftVal.(type) {
		case []interface{}:
			items = v
		case RangeResult:
			items = v.Values
		default:
			return nil, t.errfNode(e, "map target is not an array, it's a %T — gremlin is confused", leftVal)
		}

		var result []interface{}

		// Iterate and map
		for _, item := range items {
			// Create a new scope for the iteration
			// We copy the current context to allow access to outer variables
			newCtx := make(map[string]interface{})
			if ctx != nil {
				for k, v := range ctx {
					newCtx[k] = v
				}
			}
			// Bind the iterator variable
			newCtx[e.Iterator.Value] = item
			// Evaluate the body
			mappedVal, err := t.evalExpression(e.Body, newCtx)
			if err != nil {
				return nil, err
			}
			result = append(result, mappedVal)
		}
		return result, nil

	case *ast.InterpolatedString:
		// Evaluate interpolations and build the final string
		var result strings.Builder
		for _, part := range e.Parts {
			switch p := part.(type) {
			case string:
				result.WriteString(p)
			case ast.Expression:

				if ident, ok := p.(*ast.Identifier); ok {
					found := false
					if ctx != nil {
						_, found = ctx[ident.Value]
					}

					if !found {

						if e.Token.Type == token.TEMPLATESTR {
							result.WriteString("${")
							result.WriteString(ident.Value)
							result.WriteString("}")
						} else {
							// Raw string uses {var}
							result.WriteString("{")
							result.WriteString(ident.Value)
							result.WriteString("}")
						}
						continue
					}
				}

				val, err := t.evalExpression(p, ctx)
				if err != nil {
					return nil, err
				}
				result.WriteString(fmt.Sprintf("%v", val))
			}
		}
		return result.String(), nil
	case *ast.Identifier:
		// Variable lookup: check context (local) first, then symbol table (global)
		if ctx != nil {
			if val, ok := ctx[e.Value]; ok {
				return val, nil
			}
		}
		if val, ok := t.symbolTable[e.Value]; ok {
			return val, nil
		}
		return e.Value, nil
	case *ast.ObjectLiteral:
		obj := make(map[string]interface{})

		localCtx := make(map[string]interface{})
		if ctx != nil {
			for k, v := range ctx {
				localCtx[k] = v
			}
		}

		for _, decl := range e.Declarations {
			val, err := t.evalExpression(decl.Value, localCtx)
			if err != nil {
				return nil, err
			}
			localCtx[decl.Name.Value] = val
		}

		// Evaluate properties using local context
		for _, key := range e.Keys {
			valExpr := e.Properties[key]
			if valExpr == nil {
				continue
			}
			val, err := t.evalExpression(valExpr, localCtx)
			if err != nil {
				return nil, err
			}
			obj[key] = val
		}
		return obj, nil
	case *ast.ArrayLiteral:
		arr := make([]interface{}, 0, len(e.Elements))
		for _, el := range e.Elements {
			val, err := t.evalExpression(el, ctx)
			if err != nil {
				return nil, err
			}
			// If the element is a RangeResult, flatten it
			if rr, ok := val.(RangeResult); ok {
				arr = append(arr, rr.Values...)
			} else {
				arr = append(arr, val)
			}
		}
		return arr, nil

	case *ast.RangeExpression:
		// Evaluate start, end and optional step
		startV, err := t.evalExpression(e.Start, ctx)
		if err != nil {
			return nil, err
		}
		endV, err := t.evalExpression(e.End, ctx)
		if err != nil {
			return nil, err
		}

		var stepV interface{}
		if e.Step != nil {
			stepV, err = t.evalExpression(e.Step, ctx)
			if err != nil {
				return nil, err
			}
		}

		// Check if both start and end are strings (String Range)
		if startStr, ok1 := startV.(string); ok1 {
			if endStr, ok2 := endV.(string); ok2 {
				// String Range: find numeric suffix and increment it
				return t.evalStringRange(startStr, endStr, stepV, e)
			}
		}

		// Integer Range (original behavior)
		sInt, ok1 := startV.(int64)
		eInt, ok2 := endV.(int64)
		if !ok1 || !ok2 {
			return nil, t.errfNodeMsg(e, ie.RangeBoundsNotIntegers(startV, endV))
		}

		step := int64(1)
		if stepV != nil {
			if st, ok := stepV.(int64); ok {
				step = st
			} else {
				return nil, t.errfNodeMsg(e, ie.StepNotInteger(stepV))
			}
		} else {
			if sInt > eInt {
				step = -1
			}
		}

		if step == 0 {
			return nil, t.errfNodeMsg(e, ie.StepCannotBeZero())
		}

		res := make([]interface{}, 0)
		if step > 0 {
			for i := sInt; i <= eInt; i += step {
				res = append(res, i)
			}
		} else {
			for i := sInt; i >= eInt; i += step {
				res = append(res, i)
			}
		}
		return RangeResult{Values: res}, nil
	case *ast.ArrayTemplate:
		result := make([]interface{}, 0, len(e.Rows))
		keys := e.Template.Keys

		// Detect if this is an implicit template (single field matching map parameter)
		isImplicitTemplate := false
		if e.Map != nil && len(keys) == 1 && keys[0] == e.Map.Param.Value {
			isImplicitTemplate = true
		}

		for _, row := range e.Rows {
			// First, evaluate all expressions in the row
			evaluatedRow := make([]interface{}, len(row))
			for i, expr := range row {
				val, err := t.evalExpression(expr, ctx)
				if err != nil {
					return nil, err
				}
				if rr, ok := val.(RangeResult); ok {
					evaluatedRow[i] = rr.Values
				} else {
					evaluatedRow[i] = val
				}
			}

			// Check if we have ranges that need zipping
			// If we have arrays, we zip them up to the shortest length
			hasArrays := false
			minArrayLength := -1

			for _, val := range evaluatedRow {
				if arr, ok := val.([]interface{}); ok {
					isObjectArray := false
					if len(arr) > 0 {
						if _, isMap := arr[0].(map[string]interface{}); isMap {
							isObjectArray = true
						}
					}

					if !isObjectArray {
						hasArrays = true
						if minArrayLength == -1 || len(arr) < minArrayLength {
							minArrayLength = len(arr)
						}
					}
				}
			}

			// Range Zipping: if we have arrays, zip them
			if hasArrays && minArrayLength > 0 {
				// Create multiple objects, one for each index up to minArrayLength
				for idx := 0; idx < minArrayLength; idx++ {
					var itemValue interface{}

					if isImplicitTemplate {
						// For implicit templates, pass the value directly
						if arr, ok := evaluatedRow[0].([]interface{}); ok {
							itemValue = arr[idx]
						} else {
							itemValue = evaluatedRow[0]
						}
					} else {
						// For explicit templates, create an object
						rowObj := make(map[string]interface{})
						for i, val := range evaluatedRow {
							if i >= len(keys) {
								break
							}
							key := keys[i]

							// If it's an array, take the element at idx
							if arr, ok := val.([]interface{}); ok {
								rowObj[key] = arr[idx]
							} else {
								// If it's not an array, use the same value for all rows
								rowObj[key] = val
							}
						}
						itemValue = rowObj
					}

					// Apply Map Clause if present
					if e.Map != nil {
						mapCtx := make(map[string]interface{})
						for k, v := range ctx {
							mapCtx[k] = v
						}
						mapCtx[e.Map.Param.Value] = itemValue

						mappedVal, err := t.evalExpression(e.Map.Body, mapCtx)
						if err != nil {
							return nil, err
						}
						result = append(result, mappedVal)
					} else {
						result = append(result, itemValue)
					}
				}
			} else {
				// No zipping needed
				var itemValue interface{}

				if isImplicitTemplate {
					// For implicit templates, pass the value directly
					itemValue = evaluatedRow[0]
				} else {
					// For explicit templates, create an object
					rowObj := make(map[string]interface{})
					for i, val := range evaluatedRow {
						if i >= len(keys) {
							break
						}
						key := keys[i]
						rowObj[key] = val
					}
					itemValue = rowObj
				}

				// Apply Map Clause if present
				if e.Map != nil {
					mapCtx := make(map[string]interface{})
					for k, v := range ctx {
						mapCtx[k] = v
					}
					mapCtx[e.Map.Param.Value] = itemValue

					mappedVal, err := t.evalExpression(e.Map.Body, mapCtx)
					if err != nil {
						return nil, err
					}
					result = append(result, mappedVal)
				} else {
					result = append(result, itemValue)
				}
			}
		}
		return result, nil
	case *ast.BinaryExpression:
		left, err := t.evalExpression(e.Left, ctx)
		if err != nil {
			return nil, err
		}
		right, err := t.evalExpression(e.Right, ctx)
		if err != nil {
			return nil, err
		}

		return t.evalBinary(left, e.Operator, right)
	case *ast.ConditionalExpression:
		condition, err := t.evalExpression(e.Condition, ctx)
		if err != nil {
			return nil, err
		}

		// Convert to boolean
		isTruthy := t.isTruthy(condition)

		if isTruthy {
			return t.evalExpression(e.Consequence, ctx)
		} else {
			return t.evalExpression(e.Alternative, ctx)
		}
	case *ast.MemberExpression:
		leftVal, err := t.evalExpression(e.Left, ctx)
		if err != nil {
			return nil, err
		}

		// Handle map access
		if obj, ok := leftVal.(map[string]interface{}); ok {
			if val, ok := obj[e.Property.Value]; ok {
				return val, nil
			}
			// Debug info suppressed
			return nil, t.errfNode(e, "property %q not found — gremlin searched everywhere", e.Property.Value)
		}
		return nil, t.errfNodeMsg(e, ie.NotAnObject())
	default:
		return nil, t.errfNode(expr, "unknown expression type: %T", expr)
	}
}

func (t *Transpiler) evalBinary(left interface{}, op string, right interface{}) (interface{}, error) {
	// Prevent applying numeric/string operators directly to a RangeResult
	if _, ok := left.(RangeResult); ok {
		return nil, t.errMsg(fmt.Sprintf("cannot apply operator %q to a range — expand it or use in an array context", op))
	}
	if _, ok := right.(RangeResult); ok {
		return nil, t.errMsg(fmt.Sprintf("cannot apply operator %q to a range — expand it or use in an array context", op))
	}
	switch op {
	case "+":
		// String concatenation
		if lStr, ok := left.(string); ok {
			return lStr + fmt.Sprintf("%v", right), nil
		}
		if rStr, ok := right.(string); ok {
			return fmt.Sprintf("%v", left) + rStr, nil
		}
		// Numeric addition
		lFloat, lIsFloat := toFloat(left)
		rFloat, rIsFloat := toFloat(right)
		if lIsFloat || rIsFloat {
			return lFloat + rFloat, nil
		}
		if lInt, ok := left.(int64); ok {
			if rInt, ok := right.(int64); ok {
				return lInt + rInt, nil
			}
		}
	case "-":
		// Numeric subtraction
		lFloat, lIsFloat := toFloat(left)
		rFloat, rIsFloat := toFloat(right)
		if lIsFloat || rIsFloat {
			return lFloat - rFloat, nil
		}
		if lInt, ok := left.(int64); ok {
			if rInt, ok := right.(int64); ok {
				return lInt - rInt, nil
			}
		}
	case "*":
		// Numeric multiplication
		lFloat, lIsFloat := toFloat(left)
		rFloat, rIsFloat := toFloat(right)
		if lIsFloat || rIsFloat {
			return lFloat * rFloat, nil
		}
		if lInt, ok := left.(int64); ok {
			if rInt, ok := right.(int64); ok {
				return lInt * rInt, nil
			}
		}
	case "/":
		// Numeric division
		lFloat, lIsFloat := toFloat(left)
		rFloat, rIsFloat := toFloat(right)
		if lIsFloat || rIsFloat {
			if rFloat == 0 {
				return nil, t.errMsg(ie.DivisionByZero())
			}
			return lFloat / rFloat, nil
		}
		if lInt, ok := left.(int64); ok {
			if rInt, ok := right.(int64); ok {
				if rInt == 0 {
					return nil, t.errMsg(ie.DivisionByZero())
				}
				return lInt / rInt, nil
			}
		}
	case "%":
		// Int modulo: accept int/int64 combinations
		if lInt, okL := toInt64(left); okL {
			if rInt, okR := toInt64(right); okR {
				if rInt == 0 {
					return nil, t.errMsg(ie.ModuloByZero())
				}
				return lInt % rInt, nil
			}
		}
		// If we reach here, the types were not int/int64 — fall through to unsupported op
	case "==":
		return t.compareEqual(left, right), nil
	case "!=":
		return !t.compareEqual(left, right), nil
	case "<":
		return t.compareLess(left, right)
	case ">":
		return t.compareLess(right, left)
	case "<=":
		eq := t.compareEqual(left, right)
		if eq {
			return true, nil
		}
		return t.compareLess(left, right)
	case ">=":
		eq := t.compareEqual(left, right)
		if eq {
			return true, nil
		}
		return t.compareLess(right, left)
	case "&&":
		// Logical AND: both operands must be truthy
		return t.isTruthy(left) && t.isTruthy(right), nil
	case "||":
		// Logical OR: at least one operand must be truthy
		return t.isTruthy(left) || t.isTruthy(right), nil
	}
	return nil, t.errMsg(ie.UnsupportedBinaryOp(left, op, right))
}

func toFloat(val interface{}) (float64, bool) {
	switch v := val.(type) {
	case float64:
		return v, true
	case int64:
		return float64(v), false
	case int:
		return float64(v), false
	}
	return 0, false
}

func toInt64(val interface{}) (int64, bool) {
	switch v := val.(type) {
	case int64:
		return v, true
	case int:
		return int64(v), true
	}
	return 0, false
}
func (t *Transpiler) isTruthy(val interface{}) bool {
	switch v := val.(type) {
	case bool:
		return v
	case int64:
		return v != 0
	case float64:
		return v != 0.0
	case string:
		return v != ""
	case nil:
		return false
	default:
		return true
	}
}

func (t *Transpiler) compareEqual(left, right interface{}) bool {
	// Handle mixed numeric types
	lFloat, lIsFloat := toFloat(left)
	rFloat, rIsFloat := toFloat(right)
	if lIsFloat && rIsFloat {
		return lFloat == rFloat
	}

	// Handle same types
	switch l := left.(type) {
	case int64:
		if r, ok := right.(int64); ok {
			return l == r
		}
	case float64:
		if r, ok := right.(float64); ok {
			return l == r
		}
	case string:
		if r, ok := right.(string); ok {
			return l == r
		}
	case bool:
		if r, ok := right.(bool); ok {
			return l == r
		}
	}
	return false
}

func (t *Transpiler) compareLess(left, right interface{}) (bool, error) {
	// Handle mixed numeric types
	lFloat, lIsFloat := toFloat(left)
	rFloat, rIsFloat := toFloat(right)
	if lIsFloat && rIsFloat {
		return lFloat < rFloat, nil
	}

	switch l := left.(type) {
	case int64:
		if r, ok := right.(int64); ok {
			return l < r, nil
		}
	case float64:
		if r, ok := right.(float64); ok {
			return l < r, nil
		}
	case string:
		if r, ok := right.(string); ok {
			return l < r, nil
		}
	}
	return false, t.errMsg(ie.UnsupportedComparison(left, right))
}

// evalStringRange handles ranges of strings with numeric suffixes (e.g., IP addresses)
// Example: "192.168.1.100".."192.168.1.109" generates ["192.168.1.100", "192.168.1.101", ...]
func (t *Transpiler) evalStringRange(start, end string, stepV interface{}, node ast.Node) (interface{}, error) {
	// Find the numeric suffix in both strings
	// We'll look for the last sequence of digits
	var startPrefix, endPrefix string
	var startNum, endNum int64
	var foundStart, foundEnd bool

	// Extract numeric suffix from start
	for i := len(start) - 1; i >= 0; i-- {
		if start[i] < '0' || start[i] > '9' {
			// Found non-digit, extract number after this position
			if i < len(start)-1 {
				startPrefix = start[:i+1]
				numStr := start[i+1:]
				if n, err := fmt.Sscanf(numStr, "%d", &startNum); n == 1 && err == nil {
					foundStart = true
				}
			}
			break
		}
		if i == 0 {
			// Entire string is a number
			startPrefix = ""
			if n, err := fmt.Sscanf(start, "%d", &startNum); n == 1 && err == nil {
				foundStart = true
			}
			break
		}
	}

	// Extract numeric suffix from end
	for i := len(end) - 1; i >= 0; i-- {
		if end[i] < '0' || end[i] > '9' {
			if i < len(end)-1 {
				endPrefix = end[:i+1]
				numStr := end[i+1:]
				if n, err := fmt.Sscanf(numStr, "%d", &endNum); n == 1 && err == nil {
					foundEnd = true
				}
			}
			break
		}
		if i == 0 {
			endPrefix = ""
			if n, err := fmt.Sscanf(end, "%d", &endNum); n == 1 && err == nil {
				foundEnd = true
			}
			break
		}
	}

	if !foundStart || !foundEnd {
		return nil, t.errfNode(node, "string range requires numeric suffix in both start and end (e.g., \"192.168.1.100\"..\"192.168.1.109\")")
	}

	if startPrefix != endPrefix {
		return nil, t.errfNode(node, "string range prefixes must match (start: %q, end: %q)", startPrefix, endPrefix)
	}

	// Determine step
	step := int64(1)
	if stepV != nil {
		if st, ok := stepV.(int64); ok {
			step = st
		} else {
			return nil, t.errfNode(node, "step must be an integer for string ranges")
		}
	} else {
		if startNum > endNum {
			step = -1
		}
	}

	if step == 0 {
		return nil, t.errfNode(node, "step cannot be zero")
	}

	// Calculate number of digits in original (for zero-padding)
	startStr := start[len(startPrefix):]
	padding := len(startStr)

	// Generate range
	res := make([]interface{}, 0)
	if step > 0 {
		for i := startNum; i <= endNum; i += step {
			// Format with zero-padding if original had it
			if padding > 1 && startStr[0] == '0' {
				res = append(res, fmt.Sprintf("%s%0*d", startPrefix, padding, i))
			} else {
				res = append(res, fmt.Sprintf("%s%d", startPrefix, i))
			}
		}
	} else {
		for i := startNum; i >= endNum; i += step {
			if padding > 1 && startStr[0] == '0' {
				res = append(res, fmt.Sprintf("%s%0*d", startPrefix, padding, i))
			} else {
				res = append(res, fmt.Sprintf("%s%d", startPrefix, i))
			}
		}
	}

	return res, nil
}

// wtf???

// SetStreamingMode configures streaming behavior
func (t *Transpiler) SetStreamingMode(enabled bool, threshold int64) {
	t.streamingEnabled = enabled
	if threshold > 0 {
		t.streamThreshold = threshold
	}
}

// estimateRangeSize calculates the size of a range expression
func (t *Transpiler) estimateRangeSize(e *ast.RangeExpression) int64 {
	// Try to evaluate start and end as constants
	startV, err := t.evalExpression(e.Start, nil)
	if err != nil {
		return 0
	}
	endV, err := t.evalExpression(e.End, nil)
	if err != nil {
		return 0
	}

	startInt, ok1 := startV.(int64)
	endInt, ok2 := endV.(int64)
	if !ok1 || !ok2 {
		return 0
	}

	step := int64(1)
	if e.Step != nil {
		stepV, err := t.evalExpression(e.Step, nil)
		if err == nil {
			if st, ok := stepV.(int64); ok {
				step = st
			}
		}
	} else {
		if startInt > endInt {
			step = -1
		}
	}

	if step == 0 {
		return 0
	}

	var size int64
	if step > 0 {
		size = (endInt-startInt)/step + 1
	} else {
		size = (startInt-endInt)/(-step) + 1
	}

	if size < 0 {
		return 0
	}
	return size
}

// shouldUseStreaming determines if streaming should be used for an expression
func (t *Transpiler) shouldUseStreaming(expr ast.Expression) bool {
	if !t.streamingEnabled {
		return false
	}

	switch e := expr.(type) {
	case *ast.RangeExpression:
		size := t.estimateRangeSize(e)
		return size > t.streamThreshold
	case *ast.MapExpression:
		// Check if the map body is another map (nested maps)
		if _, isMap := e.Body.(*ast.MapExpression); isMap {
			return true
		}
		// Check if the source is a large range
		return t.shouldUseStreaming(e.Left)
	case *ast.ArrayTemplate:
		// Check if any rows contain large ranges
		for _, row := range e.Rows {
			for _, expr := range row {
				if t.shouldUseStreaming(expr) {
					return true
				}
			}
		}
	}
	return false
}
