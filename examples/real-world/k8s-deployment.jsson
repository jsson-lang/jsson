// Kubernetes Multi-Environment Deployment Configuration
// Real-world DevOps use case: Generate deployment configs for multiple environments
// Shows how JSSON reduces repetition in infrastructure-as-code

// Application deployments across environments
deployments [
  template { appName, env, replicas }
  
  map (deploy) = {
    apiVersion = "apps/v1"
    kind = "Deployment"
    name = deploy.appName + "-" + deploy.env
    namespace = deploy.env
    replicas = deploy.replicas
    
    // Container image based on environment
    image = "myregistry/" + deploy.appName + ":" + (deploy.env == "prod" ? "stable" : "latest")
    
    // Resource limits based on environment
    memoryRequest = deploy.env == "prod" ? "512Mi" : "256Mi"
    cpuRequest = deploy.env == "prod" ? "500m" : "250m"
    memoryLimit = deploy.env == "prod" ? "1Gi" : "512Mi"
    cpuLimit = deploy.env == "prod" ? "1000m" : "500m"
    
    // Environment variables
    environment = deploy.env
    logLevel = deploy.env == "prod" ? "error" : "debug"
  }
  
  // Production: high replicas
  "api", "prod", 5
  "web", "prod", 3
  "worker", "prod", 4
  
  // Staging: medium replicas
  "api", "staging", 2
  "web", "staging", 2
  "worker", "staging", 1
  
  // Development: minimal replicas
  "api", "dev", 1
  "web", "dev", 1
  "worker", "dev", 1
]

// Services for each deployment
services [
  template { appName, env, port }
  
  map (svc) = {
    apiVersion = "v1"
    kind = "Service"
    name = svc.appName + "-" + svc.env
    namespace = svc.env
    type = svc.env == "prod" ? "LoadBalancer" : "ClusterIP"
    port = svc.port
    targetPort = svc.port
    protocol = "TCP"
    app = svc.appName
    environment = svc.env
  }
  
  "api", "prod", 8080
  "web", "prod", 3000
  "api", "staging", 8080
  "web", "staging", 3000
  "api", "dev", 8080
  "web", "dev", 3000
]

// ConfigMaps for application configuration
configMaps [
  template { env }
  
  map (cfg) = {
    apiVersion = "v1"
    kind = "ConfigMap"
    name = "app-config-" + cfg.env
    namespace = cfg.env
    databaseHost = "postgres-" + cfg.env + ".internal"
    redisHost = "redis-" + cfg.env + ".internal"
    cacheTTL = cfg.env == "prod" ? "3600" : "60"
    featureFlags = cfg.env == "prod" ? "stable" : "experimental"
  }
  
  "prod"
  "staging"
  "dev"
]

// WHY JSSON FOR KUBERNETES?
// - Reduce repetition: Define once, generate for multiple environments
// - Conditional logic: Different configs for prod/staging/dev
// - Consistency: Ensure naming conventions across all resources
// - Maintainability: Change one template, update all deployments
